name: Build and Push to ECR

on:
  push:
    branches: [ main ]

  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: k8s-assessment
  ECR_REGISTRY: 084828598848.dkr.ecr.us-east-1.amazonaws.com

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Shallow clones should be disabled for better analysis

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      working-directory: ./app
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-flask

    - name: Run Python unit tests
      working-directory: ./app
      run: |
        echo "🧪 Running Python unit tests with pytest..."
        pytest tests/ -v --cov=. --cov-report=xml --cov-report=html --cov-report=term-missing
        echo "✅ All tests passed!"

    - name: Upload test coverage to artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-coverage-report
        path: |
          app/coverage.xml
          app/htmlcov/

    - name: OWASP Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      id: dependency-check
      with:
        project: 'Flask-Health-App'
        path: './app'
        format: 'ALL'
        args: >
          --enableRetired
          --enableExperimental
          --failOnCVSS 7
          --disableOssIndex
          --out reports
          --log reports/dependency-check.log

    - name: Upload OWASP Dependency Check results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: owasp-dependency-check-reports
        path: |
          reports/dependency-check-report.html
          reports/dependency-check-report.json
          reports/dependency-check-report.xml
          reports/dependency-check.log

    - name: Check for High/Critical Vulnerabilities
      run: |
        echo "🔍 Checking for High/Critical vulnerabilities..."
        
        if [ -f "reports/dependency-check-report.json" ]; then
          # Extract vulnerability count
          HIGH_CRITICAL_COUNT=$(cat reports/dependency-check-report.json | jq '.dependencies[].vulnerabilities[]? | select(.severity == "HIGH" or .severity == "CRITICAL")' | jq -s 'length')
          
          echo "📊 High/Critical vulnerabilities found: $HIGH_CRITICAL_COUNT"
          
          if [ "$HIGH_CRITICAL_COUNT" -gt 0 ]; then
            echo "❌ Found $HIGH_CRITICAL_COUNT High/Critical vulnerabilities!"
            echo "🔗 Check the detailed report in artifacts"
            
            # Show summary of vulnerabilities
            echo "📋 Vulnerability Summary:"
            cat reports/dependency-check-report.json | jq -r '.dependencies[].vulnerabilities[]? | select(.severity == "HIGH" or .severity == "CRITICAL") | "- " + .name + " (" + .severity + "): " + .description'
            
            exit 1
          else
            echo "✅ No High/Critical vulnerabilities found!"
          fi
        else
          echo "⚠️ Dependency check report not found"
        fi

    - name: SonarCloud Scan
      uses: SonarSource/sonarqube-scan-action@v5.0.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      with:
        projectBaseDir: ./app

    - name: SonarCloud Quality Gate Check
      id: quality-gate
      run: |
        echo "⏳ Waiting for SonarCloud Quality Gate..."
        
        # Debug: Check if report-task.txt exists and show content
        if [ -f "./app/.scannerwork/report-task.txt" ]; then
          echo "📋 Report task file content:"
          cat ./app/.scannerwork/report-task.txt
          echo ""
          
          # Extract task ID more carefully
          TASK_ID=$(grep "ceTaskId=" ./app/.scannerwork/report-task.txt | cut -d'=' -f2)
          echo "🆔 Task ID: $TASK_ID"
          
          if [ -n "$TASK_ID" ]; then
            TASK_URL="https://sonarcloud.io/api/ce/task?id=$TASK_ID"
            echo "🔗 Task URL: $TASK_URL"
            
            # Wait for analysis to complete
            for i in {1..60}; do
              sleep 10
              echo "⏳ Checking analysis status (attempt $i/60)..."
              
              RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" "$TASK_URL")
              TASK_STATUS=$(echo "$RESPONSE" | jq -r '.task.status // "PENDING"')
              
              echo "📊 Analysis status: $TASK_STATUS"
              
              if [ "$TASK_STATUS" = "SUCCESS" ]; then
                echo "✅ Analysis completed successfully!"
                break
              elif [ "$TASK_STATUS" = "FAILED" ] || [ "$TASK_STATUS" = "CANCELLED" ]; then
                echo "❌ Analysis failed with status: $TASK_STATUS"
                echo "Response: $RESPONSE"
                exit 1
              fi
              
              if [ $i -eq 60 ]; then
                echo "❌ Timeout waiting for analysis to complete"
                exit 1
              fi
            done
          else
            echo "❌ Could not extract task ID from report"
            exit 1
          fi
        else
          echo "❌ Report task file not found"
          exit 1
        fi
        
        # Check Quality Gate
        echo "🎯 Checking Quality Gate status..."
        sleep 5  # Give SonarCloud time to process
        
        PROJECT_STATUS_URL="https://sonarcloud.io/api/qualitygates/project_status?projectKey=abdulmoizz44_ebryx-k8s-project"
        QG_RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" "$PROJECT_STATUS_URL")
        QUALITY_GATE_STATUS=$(echo "$QG_RESPONSE" | jq -r '.projectStatus.status // "ERROR"')
        
        echo "🎯 Quality Gate Status: $QUALITY_GATE_STATUS"
        
        if [ "$QUALITY_GATE_STATUS" = "OK" ]; then
          echo "✅ Quality Gate PASSED! 🎉"
          echo "🚀 Proceeding with deployment..."
        else
          echo "❌ Quality Gate FAILED! Status: $QUALITY_GATE_STATUS"
          echo "📄 Full response: $QG_RESPONSE"
          echo "🔗 Check details at: https://sonarcloud.io/project/overview?id=abdulmoizz44_ebryx-k8s-project"
          exit 1
        fi

    - name: Dockerfile Security Linting with Hadolint
      uses: hadolint/hadolint-action@v3.1.0
      with:
        dockerfile: ./app/Dockerfile
        failure-threshold: error
        verbose: true

    - name: Upload Hadolint results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: hadolint-results
        path: hadolint-results.sarif

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        mask-password: false

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      working-directory: ./app
      run: |
        IMAGE_TAG=${GITHUB_SHA:0:6}
        
        echo "Building Docker image with tag: $IMAGE_TAG"
        docker build -t $ECR_REPOSITORY:$IMAGE_TAG .
        
        docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "Pushing image with commit SHA: $IMAGE_TAG"
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "Pushing latest tag..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "image-latest=$ECR_REGISTRY/$ECR_REPOSITORY:latest" >> $GITHUB_OUTPUT
        echo "commit-sha=$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Install Helm
      uses: azure/setup-helm@v4
      with:
        version: '3.12.0'

    - name: Configure kubectl for EKS
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name ${{ secrets.EKS_CLUSTER_NAME }}
        kubectl config current-context

    - name: Deploy to EKS using Helm
      run: |
        IMAGE_TAG=${GITHUB_SHA:0:6}
        
        echo "Deploying with image tag: $IMAGE_TAG"
        
        cd simple-helm/flask-app
        
        # Update the image tag in values.yaml and deploy
        helm upgrade --install flask-health-app . \
          --set image.tag=$IMAGE_TAG \
          --namespace flask-app \
          --create-namespace \
          --wait \
          --timeout=300s
        
        echo "Deployment completed successfully!"
        
        # Verify deployment
        kubectl get pods -l app=flask-health-app
        kubectl get services flask-health-app
