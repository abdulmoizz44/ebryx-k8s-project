name: Build and Push to ECR

on:
  push:
    branches: [ main ]

  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: k8s-assessment
  ECR_REGISTRY: 084828598848.dkr.ecr.us-east-1.amazonaws.com

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Shallow clones should be disabled for better analysis

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      working-directory: ./app
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-flask

    - name: Run Python unit tests
      working-directory: ./app
      run: |
        echo "üß™ Running Python unit tests with pytest..."
        pytest tests/ -v --cov=. --cov-report=xml --cov-report=html --cov-report=term-missing
        echo "‚úÖ All tests passed!"

    - name: Upload test coverage to artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-coverage-report
        path: |
          app/coverage.xml
          app/htmlcov/

    - name: OWASP Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      id: dependency-check
      with:
        project: 'Flask-Health-App'
        path: './app'
        format: 'ALL'
        args: >
          --enableRetired
          --enableExperimental
          --failOnCVSS 7
          --disableOssIndex
          --out reports
          --log reports/dependency-check.log

    - name: Upload OWASP Dependency Check results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: owasp-dependency-check-reports
        path: |
          reports/dependency-check-report.html
          reports/dependency-check-report.json
          reports/dependency-check-report.xml
          reports/dependency-check.log

    - name: Check for High/Critical Vulnerabilities
      run: |
        echo "üîç Checking for High/Critical vulnerabilities..."
        
        if [ -f "reports/dependency-check-report.json" ]; then
          # Extract vulnerability count
          HIGH_CRITICAL_COUNT=$(cat reports/dependency-check-report.json | jq '.dependencies[].vulnerabilities[]? | select(.severity == "HIGH" or .severity == "CRITICAL")' | jq -s 'length')
          
          echo "üìä High/Critical vulnerabilities found: $HIGH_CRITICAL_COUNT"
          
          if [ "$HIGH_CRITICAL_COUNT" -gt 0 ]; then
            echo "‚ùå Found $HIGH_CRITICAL_COUNT High/Critical vulnerabilities!"
            echo "üîó Check the detailed report in artifacts"
            
            # Show summary of vulnerabilities
            echo "üìã Vulnerability Summary:"
            cat reports/dependency-check-report.json | jq -r '.dependencies[].vulnerabilities[]? | select(.severity == "HIGH" or .severity == "CRITICAL") | "- " + .name + " (" + .severity + "): " + .description'
            
            exit 1
          else
            echo "‚úÖ No High/Critical vulnerabilities found!"
          fi
        else
          echo "‚ö†Ô∏è Dependency check report not found"
        fi

    - name: SonarCloud Scan
      uses: SonarSource/sonarqube-scan-action@v5.0.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      with:
        projectBaseDir: ./app

    - name: SonarCloud Quality Gate Check
      id: quality-gate
      run: |
        echo "‚è≥ Waiting for SonarCloud Quality Gate..."
        
        # Debug: Check if report-task.txt exists and show content
        if [ -f "./app/.scannerwork/report-task.txt" ]; then
          echo "üìã Report task file content:"
          cat ./app/.scannerwork/report-task.txt
          echo ""
          
          # Extract task ID more carefully
          TASK_ID=$(grep "ceTaskId=" ./app/.scannerwork/report-task.txt | cut -d'=' -f2)
          echo "üÜî Task ID: $TASK_ID"
          
          if [ -n "$TASK_ID" ]; then
            TASK_URL="https://sonarcloud.io/api/ce/task?id=$TASK_ID"
            echo "üîó Task URL: $TASK_URL"
            
            # Wait for analysis to complete
            for i in {1..60}; do
              sleep 10
              echo "‚è≥ Checking analysis status (attempt $i/60)..."
              
              RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" "$TASK_URL")
              TASK_STATUS=$(echo "$RESPONSE" | jq -r '.task.status // "PENDING"')
              
              echo "üìä Analysis status: $TASK_STATUS"
              
              if [ "$TASK_STATUS" = "SUCCESS" ]; then
                echo "‚úÖ Analysis completed successfully!"
                break
              elif [ "$TASK_STATUS" = "FAILED" ] || [ "$TASK_STATUS" = "CANCELLED" ]; then
                echo "‚ùå Analysis failed with status: $TASK_STATUS"
                echo "Response: $RESPONSE"
                exit 1
              fi
              
              if [ $i -eq 60 ]; then
                echo "‚ùå Timeout waiting for analysis to complete"
                exit 1
              fi
            done
          else
            echo "‚ùå Could not extract task ID from report"
            exit 1
          fi
        else
          echo "‚ùå Report task file not found"
          exit 1
        fi
        
        # Check Quality Gate
        echo "üéØ Checking Quality Gate status..."
        sleep 5  # Give SonarCloud time to process
        
        PROJECT_STATUS_URL="https://sonarcloud.io/api/qualitygates/project_status?projectKey=abdulmoizz44_ebryx-k8s-project"
        QG_RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" "$PROJECT_STATUS_URL")
        QUALITY_GATE_STATUS=$(echo "$QG_RESPONSE" | jq -r '.projectStatus.status // "ERROR"')
        
        echo "üéØ Quality Gate Status: $QUALITY_GATE_STATUS"
        
        if [ "$QUALITY_GATE_STATUS" = "OK" ]; then
          echo "‚úÖ Quality Gate PASSED! üéâ"
          echo "üöÄ Proceeding with deployment..."
        else
          echo "‚ùå Quality Gate FAILED! Status: $QUALITY_GATE_STATUS"
          echo "üìÑ Full response: $QG_RESPONSE"
          echo "üîó Check details at: https://sonarcloud.io/project/overview?id=abdulmoizz44_ebryx-k8s-project"
          exit 1
        fi

    - name: Dockerfile Security Linting with Hadolint
      uses: hadolint/hadolint-action@v3.1.0
      with:
        dockerfile: ./app/Dockerfile
        failure-threshold: error
        verbose: true

    - name: Upload Hadolint results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: hadolint-results
        path: hadolint-results.sarif

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        mask-password: false

    - name: Build Docker image
      id: build-image
      working-directory: ./app
      run: |
        # Use short Git SHA for tagging (e.g., myapp:a1b2c3d)
        SHORT_SHA=${GITHUB_SHA:0:7}
        
        echo "üî® Building Docker image with short Git SHA tag: $SHORT_SHA"
        docker build -t $ECR_REPOSITORY:$SHORT_SHA .
        docker tag $ECR_REPOSITORY:$SHORT_SHA $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA
        docker tag $ECR_REPOSITORY:$SHORT_SHA $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "‚úÖ Docker image built successfully!"
        echo "üìã Local image: $ECR_REPOSITORY:$SHORT_SHA"
        echo "üìã ECR image: $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA"
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA" >> $GITHUB_OUTPUT
        echo "image-latest=$ECR_REGISTRY/$ECR_REPOSITORY:latest" >> $GITHUB_OUTPUT
        echo "commit-sha=$SHORT_SHA" >> $GITHUB_OUTPUT

    - name: Run Trivy vulnerability scanner (SARIF)
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ env.ECR_REPOSITORY }}:${{ steps.build-image.outputs.commit-sha }}'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Run Trivy vulnerability scanner (JSON report)
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ env.ECR_REPOSITORY }}:${{ steps.build-image.outputs.commit-sha }}'
        format: 'json'
        output: 'trivy-report.json'
      continue-on-error: true

    - name: Run Trivy vulnerability scanner (Table format)
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ env.ECR_REPOSITORY }}:${{ steps.build-image.outputs.commit-sha }}'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        vuln-type: 'os,library'
        severity: 'CRITICAL'

    - name: Upload Trivy reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: trivy-vulnerability-reports
        path: |
          trivy-results.sarif
          trivy-report.json

    - name: Analyze Trivy scan results
      run: |
        echo "üîç Analyzing Trivy vulnerability scan results..."
        
        if [ -f "trivy-report.json" ]; then
          # Count vulnerabilities by severity
          CRITICAL=$(cat trivy-report.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length')
          HIGH=$(cat trivy-report.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length')
          MEDIUM=$(cat trivy-report.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM")] | length')
          LOW=$(cat trivy-report.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "LOW")] | length')
          
          echo "üìä Vulnerability Summary:"
          echo "üî¥ Critical: $CRITICAL"
          echo "üü† High: $HIGH"
          echo "üü° Medium: $MEDIUM"
          echo "üü¢ Low: $LOW"
          
          # Only fail on CRITICAL vulnerabilities
          if [ "$CRITICAL" -gt 0 ]; then
            echo "‚ùå CRITICAL vulnerabilities found! Cannot proceed to production."
            echo "üîó Check detailed reports in artifacts or GitHub Security tab"
            echo "üö® Pipeline will fail and images will NOT be pushed to ECR"
            exit 1
          else
            echo "‚úÖ No CRITICAL vulnerabilities found! Safe to proceed with push."
            if [ "$HIGH" -gt 0 ]; then
              echo "‚ö†Ô∏è  Note: $HIGH HIGH severity vulnerabilities found (acceptable)"
            fi
            if [ "$MEDIUM" -gt 0 ]; then
              echo "üí° Note: $MEDIUM MEDIUM severity vulnerabilities found (acceptable)"
            fi
            if [ "$LOW" -gt 0 ]; then
              echo "‚ÑπÔ∏è  Note: $LOW LOW severity vulnerabilities found (acceptable)"
            fi
            echo "üìã Summary: Critical($CRITICAL), High($HIGH), Medium($MEDIUM), Low($LOW)"
            echo "üöÄ Proceeding with ECR push and deployment..."
          fi
        else
          echo "‚ö†Ô∏è Trivy report not found, proceeding with caution..."
        fi

    - name: Push images to Amazon ECR
      if: success()
      run: |
        # Use short Git SHA for tagging (e.g., k8s-assessment:a1b2c3d)
        SHORT_SHA=${GITHUB_SHA:0:7}
        
        echo "üì¶ Pushing images to ECR (security scan passed)..."
        echo "üè∑Ô∏è Pushing with short Git SHA: $SHORT_SHA"
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "‚úÖ Images pushed successfully to ECR!"
        echo "üìã Image with SHA tag: $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA"
        echo "üìã Latest image: $ECR_REGISTRY/$ECR_REPOSITORY:latest"

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Install Helm
      uses: azure/setup-helm@v4
      with:
        version: '3.12.0'

    - name: Configure kubectl for EKS
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name ${{ secrets.EKS_CLUSTER_NAME }}
        kubectl config current-context

    - name: Deploy to EKS using Helm
      run: |
        # Use short Git SHA for deployment (e.g., k8s-assessment:a1b2c3d)
        SHORT_SHA=${GITHUB_SHA:0:7}
        
        echo "üöÄ Deploying with short Git SHA tag: $SHORT_SHA"
        
        cd simple-helm/flask-app
        
        # Update the image tag in values.yaml and deploy
        helm upgrade --install flask-health-app . \
          --set image.tag=$SHORT_SHA \
          --namespace flask-app \
          --create-namespace \
          --wait \
          --timeout=300s
        
        echo "‚úÖ Deployment completed successfully!"
        echo "üìã Deployed image: $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA"
        
        # Verify deployment
        kubectl get pods -l app=flask-health-app
        kubectl get services flask-health-app
